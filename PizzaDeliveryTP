-- Variables iniciales
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local backpack = player:WaitForChild("Backpack")

-- Función de ejecución del script (lo que quieres ejecutar)
local function executeScript()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local backpack = player:WaitForChild("Backpack")
    local isMoving = false
    local targetYPosition = -60 -- Posición bajo el mapa
    local currentDoor = nil
    local targetDoor = nil -- Puerta objetivo más reciente
    local lastDoor = nil -- Última puerta visitada

    local itemsToTrack = {"A1", "A2", "A3", "B1", "B2", "B3", "B4", "B5", "B6", "C1", "C2", "C3"}

    -- Desactivar asientos
    for _, seat in pairs(workspace:GetDescendants()) do
        if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
            seat.Disabled = true
        end
    end

    -- Evitar muerte por caída
    RunService.Heartbeat:Connect(function()
        if humanoidRootPart.Position.Y < -50 then
            humanoidRootPart.Velocity = Vector3.zero
        end
    end)

    -- Función para teletransportarse instantáneamente a la puerta y bajar a Y = -60
    local function teleportToDoor(door)
        if door == lastDoor then
            print("Ya se entregó en esta puerta. No se moverá.")
            return
        end

        isMoving = true

        -- Teletransportarse directamente a la puerta, pero ajustando ligeramente la posición Y
        humanoidRootPart.CFrame = CFrame.new(door.Position.X, door.Position.Y + 2, door.Position.Z)

        -- Esperar 0.2 segundos para evitar problemas de sincronización
        wait(0.2)

        -- Bajar a Y = -60 sin suavizado
        humanoidRootPart.CFrame = CFrame.new(door.Position.X, targetYPosition, door.Position.Z)

        -- Actualizar la última puerta visitada
        lastDoor = door

        isMoving = false
    end

    -- Función para contar elementos en el backpack
    local function countItems()
        local counts = {}
        for _, itemName in ipairs(itemsToTrack) do
            counts[itemName] = 0
        end

        for _, item in ipairs(backpack:GetChildren()) do
            if counts[item.Name] ~= nil then
                counts[item.Name] += 1
            end
        end
        return counts
    end

    -- Función para verificar si todos los elementos han sido entregados
    local function allItemsDelivered(counts)
        for _, count in pairs(counts) do
            if count > 0 then
                return false
            end
        end
        return true
    end

    -- Verificar elementos en el backpack y manejar entregas
    local function checkAndDeliverItems()
        while true do
            wait(1) -- Revisar cada segundo

            local counts = countItems()
            print("Estado del backpack:", counts)

            if allItemsDelivered(counts) then
                print("Todos los elementos han sido entregados. Esperando para finalizar...")
                
                -- Determinar el tiempo de espera antes de la muerte
                local waitTime = 3
                if lastDoor then
                    waitTime = (lastDoor == targetDoor) and 1 or 3
                end

                wait(waitTime) -- Espera según la puerta

                humanoidRootPart.CFrame = CFrame.new(Vector3.new(0, -500, 0)) -- Matar al jugador
                break
            end
        end
    end

    -- Detectar cuando se equipa una pizza/soda
    character.ChildAdded:Connect(function(item)
        if item:FindFirstChild("House") then
            local house = item.House.Value
            local doors = house:GetDescendants()

            for _, door in ipairs(doors) do
                if door.Name == "GivePizza" then
                    -- Actualizar la puerta objetivo
                    targetDoor = door

                    -- Si ya está en movimiento, interrumpir para priorizar la nueva puerta
                    if isMoving then
                        isMoving = false
                    end

                    -- Iniciar el teletransporte a la nueva puerta
                    teleportToDoor(targetDoor)
                    break
                end
            end
        end
    end)

    -- Verificación de la llegada a la puerta y movimiento hacia abajo
    game.Players.LocalPlayer.Character.ChildAdded:Connect(function(item)
        if item:findFirstChild("House") then
            local house = item.House.Value
            local door = house:GetDescendants()

            for i = 1, #door do
                if door[i].Name == "GivePizza" then
                    -- Comprobar si es la misma puerta que la última
                    if lastDoor == door[i] then
                        print("Ya estamos en esta puerta. No se moverá.")
                        break
                    end
                    
                    -- Teletransportarse a la puerta instantáneamente, con ajuste en la altura (un poco arriba)
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(door[i].Position.X, door[i].Position.Y + 2, door[i].Position.Z)
                    
                    -- Esperar 0.2 segundos
                    wait(0.2)
                    
                    -- Bajar a Y = -60 sin suavizado
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(door[i].Position.X, -60, door[i].Position.Z)
                    -- Actualizar la última puerta visitada
                    lastDoor = door[i]
                    break
                end
            end
        end
    end)

    -- Iniciar revisión del backpack en paralelo
    task.spawn(checkAndDeliverItems)

    -- Detener el script al reiniciar
    player.CharacterAdded:Connect(function()
        script:Destroy()
    end)
end

-- Crear la Interfaz de Usuario
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.ResetOnSpawn = false -- Mantener la interfaz en pantalla si el jugador respawnea
ScreenGui.Parent = game.CoreGui -- Asegura que se muestra en todos los dispositivos

-- Crear el botón de ejecución
local ExecuteButton = Instance.new("TextButton")
ExecuteButton.Size = UDim2.new(0, 100, 0, 30) -- Tamaño pequeño del botón
ExecuteButton.Position = UDim2.new(0, 734, 0, 143) -- Centrar el botón en la pantalla
ExecuteButton.Text = "Ejecutar"
ExecuteButton.Font = Enum.Font.SourceSansBold
ExecuteButton.TextSize = 14 -- Tamaño del texto
ExecuteButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Color verde
ExecuteButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ExecuteButton.Parent = ScreenGui

-- Crear el botón de eliminar
local DeleteButton = Instance.new("TextButton")
DeleteButton.Size = UDim2.new(0, 100, 0, 30) -- Tamaño pequeño del botón
DeleteButton.Position = UDim2.new(0, 734, 0, 200) -- Ubicación debajo del botón de ejecutar
DeleteButton.Text = "Eliminar"
DeleteButton.Font = Enum.Font.SourceSansBold
DeleteButton.TextSize = 14 -- Tamaño del texto
DeleteButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Color rojo
DeleteButton.TextColor3 = Color3.fromRGB(255, 255, 255)
DeleteButton.Parent = ScreenGui

-- Hacer que el botón sea arrastrable
local dragging = false
local dragStart
local startPos

ExecuteButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
        dragStart = input.Position
        startPos = ExecuteButton.Position
    end
end)

ExecuteButton.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
        local delta = input.Position - dragStart
        ExecuteButton.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

ExecuteButton.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

DeleteButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        -- Eliminar ambos botones
        ExecuteButton:Destroy()
        DeleteButton:Destroy()
    end
end)

-- Ejecutar el script al hacer clic en el botón de ejecutar
ExecuteButton.MouseButton1Click:Connect(function()
    -- Ejecutar el código que deseas cuando el botón sea presionado
    executeScript()
end)
